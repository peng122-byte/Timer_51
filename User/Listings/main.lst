C51 COMPILER V9.59.0.0   MAIN                                                              12/01/2025 23:11:31 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keilc51\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          
   3          // ================= 硬件引脚定义 =================
   4          #define GPIO_DIG    P0      // 段选数据口
   5          #define GPIO_PLACE  P2      // 位选控制口
   6          
   7          sbit KEY_START = P3^0;      // 启动/暂停
   8          sbit KEY_MIN   = P3^1;      // 分钟调整
   9          sbit KEY_SEC   = P3^2;      // 秒数调整
  10          
  11          // ================= 全局变量定义 =================
  12          unsigned char code DIG_CODE[10] = {
  13              0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F
  14          }; // 共阴极 0-9 段码表
  15          
  16          unsigned char DisplayData[4]; // 显示缓冲数组，分别存 分十、分个、秒十、秒个
  17          unsigned char minute = 0;     // 分钟变量 (0-59)
  18          unsigned char second = 0;     // 秒钟变量 (0-59)
  19          unsigned char timer_count = 0;// 定时器计数器
  20          bit is_running = 0;           // 运行状态标志：0-停止，1-运行
  21          
  22          // ================= 辅助函数 =================
  23          
  24          // 简单的软件延时，用于数码管扫描
  25          void DelayIs(unsigned int t) {
  26   1          while(t--);
  27   1      }
  28          
  29          // 简单的毫秒延时，用于按键消抖
  30          void DelayMs(unsigned int ms) {
  31   1          unsigned int i, j;
  32   1          for(i = 0; i < ms; i++)
  33   1              for(j = 0; j < 110; j++);
  34   1      }
  35          
  36          // 数据处理函数：将此时的分秒拆解放入显示缓冲区
  37          void UpdateDisplayBuffer() {
  38   1          DisplayData[0] = DIG_CODE[minute / 10]; // 分钟十位
  39   1          DisplayData[1] = DIG_CODE[minute % 10]; // 分钟个位
  40   1          DisplayData[2] = DIG_CODE[second / 10]; // 秒钟十位
  41   1          DisplayData[3] = DIG_CODE[second % 10]; // 秒钟个位
  42   1      }
  43          
  44          // 数码管扫描显示函数
  45          void Display() {
  46   1          // --- 显示第1位 (左边第一位，分钟十位) ---
  47   1          GPIO_PLACE = 0xFE;  // P2.0 低电平选中
  48   1          GPIO_DIG = DisplayData[0];
  49   1          DelayIs(100);
  50   1          GPIO_DIG = 0x00;    // 消隐
  51   1      
  52   1          // --- 显示第2位 (分钟个位) ---
  53   1          GPIO_PLACE = 0xFD;  // P2.1 低电平选中
  54   1          GPIO_DIG = DisplayData[1];
C51 COMPILER V9.59.0.0   MAIN                                                              12/01/2025 23:11:31 PAGE 2   

  55   1          DelayIs(100);
  56   1          GPIO_DIG = 0x00;
  57   1      
  58   1          // --- 显示第3位 (秒钟十位) ---
  59   1          GPIO_PLACE = 0xFB;  // P2.2 低电平选中
  60   1          GPIO_DIG = DisplayData[2];
  61   1          DelayIs(100);
  62   1          GPIO_DIG = 0x00;
  63   1      
  64   1          // --- 显示第4位 (右边第一位，秒钟个位) ---
  65   1          GPIO_PLACE = 0xF7;  // P2.3 低电平选中
  66   1          GPIO_DIG = DisplayData[3];
  67   1          DelayIs(100);
  68   1          GPIO_DIG = 0x00;
  69   1      }
  70          
  71          // 按键扫描处理函数
  72          void KeyScan() {
  73   1          // 1. 启动/停止键 (P3.0)
  74   1          if (KEY_START == 0) {
  75   2              DelayMs(10); // 消抖
  76   2              if (KEY_START == 0) {
  77   3                  is_running = !is_running; // 取反运行状态
  78   3                  while(KEY_START == 0) Display(); // 等待松手，期间保持显示
  79   3              }
  80   2          }
  81   1      
  82   1          // 2. 调整分钟 (P3.1)
  83   1          if (KEY_MIN == 0) {
  84   2              DelayMs(10);
  85   2              if (KEY_MIN == 0) {
  86   3                  minute++;
  87   3                  if (minute >= 60) minute = 0;
  88   3                  UpdateDisplayBuffer(); // 更新显示数据
  89   3                  while(KEY_MIN == 0) Display(); 
  90   3              }
  91   2          }
  92   1      
  93   1          // 3. 调整秒钟 (P3.2)
  94   1          if (KEY_SEC == 0) {
  95   2              DelayMs(10);
  96   2              if (KEY_SEC == 0) {
  97   3                  second++;
  98   3                  if (second >= 60) second = 0;
  99   3                  UpdateDisplayBuffer(); // 更新显示数据
 100   3                  while(KEY_SEC == 0) Display();
 101   3              }
 102   2          }
 103   1      }
 104          
 105          // 定时器0初始化函数 (产生50ms中断，基于12MHz晶振)
 106          void Timer0_Init() {
 107   1          TMOD |= 0x01;      // 设置定时器0为模式1 (16位)
 108   1          TH0 = (65536 - 50000) / 256; // 装初值 50ms
 109   1          TL0 = (65536 - 50000) % 256;
 110   1          EA = 1;            // 开总中断
 111   1          ET0 = 1;           // 开定时器0中断
 112   1          TR0 = 1;           // 启动定时器
 113   1      }
 114          
 115          // ================= 主函数 =================
 116          void main() {
C51 COMPILER V9.59.0.0   MAIN                                                              12/01/2025 23:11:31 PAGE 3   

 117   1          UpdateDisplayBuffer(); // 初始化显示内容
 118   1          Timer0_Init();         // 初始化定时器
 119   1          
 120   1          while(1) {
 121   2              KeyScan(); // 扫描按键
 122   2              Display(); // 刷新数码管
 123   2          }
 124   1      }
 125          
 126          // ================= 中断服务函数 =================
 127          void Timer0_ISR() interrupt 1 {
 128   1          // 重新装载初值 (50ms)
 129   1          TH0 = (65536 - 50000) / 256;
 130   1          TL0 = (65536 - 50000) % 256;
 131   1          
 132   1          // 只有在运行状态下才计数
 133   1          if (is_running) {
 134   2              timer_count++;
 135   2              if (timer_count >= 20) { // 50ms * 20 = 1000ms = 1秒
 136   3                  timer_count = 0;
 137   3                  second++;
 138   3                  
 139   3                  // 进位逻辑
 140   3                  if (second >= 60) {
 141   4                      second = 0;
 142   4                      minute++;
 143   4                      if (minute >= 60) {
 144   5                          minute = 0;
 145   5                      }
 146   4                  }
 147   3                  // 每秒更新一次显示缓冲
 148   3                  UpdateDisplayBuffer();
 149   3              }
 150   2          }
 151   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    351    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
